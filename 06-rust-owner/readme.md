所有权是 Rust 最独特的特性，对语言的其余部分有着深远的影响。它使 Rust 能够在不需要垃圾收集器的情况下确保内存安全，因此了解所有权的工作原理非常重要。在本章中，我们将讨论所有权以及几个相关的特性：借用、切片以及 Rust 如何在内存中放置数据。

### 一. 什么是所有权

所有权是一组控制 Rust 程序如何管理内存的规则。所有程序都必须管理它们在运行时使用计算机内存的方式。一些语言有垃圾收集，在程序运行时不断寻找不再使用的内存；在其他语言中，程序员必须显式分配和释放内存。Rust 使用第三种方法：内存通过所有权系统进行管理，该系统具有一组编译器检查的规则。如果违反任何规则，程序将无法编译。所有权的任何功能都不会在您的程序运行时减慢它的速度。

因为所有权对许多程序员来说是一个新概念，所以确实需要一些时间来适应。好消息是，您对 Rust 和所有权系统规则的经验越丰富，您就越容易自然地开发出安全高效的代码。坚持下去！

当您了解所有权时，您将为了解使 Rust 独一无二的功能打下坚实的基础。在本章中，您将通过一些专注于非常常见的数据结构的示例来学习所有权：字符串。

#### 1. 栈和堆

许多编程语言不需要您经常考虑堆栈和堆。但是在像 Rust 这样的系统编程语言中，一个值是在堆栈上还是在堆上会影响语言的行为方式以及为什么你必须做出某些决定。本章稍后将结合堆栈和堆来描述所有权的部分，因此这里是准备工作的简要说明。

堆栈和堆都是代码在运行时可用的内存部分，但它们的结构不同。堆栈按获取值的顺序存储值，并以相反的顺序删除值。这称为后进先出。想想一堆盘子：当你添加更多盘子时，你把它们放在一堆盘子的顶部，当你需要一个盘子时，你从顶部取下一个。从中间或底部添加或移除盘子也不行！添加数据称为压入堆栈，删除数据称为弹出堆栈。存储在堆栈上的所有数据都必须具有已知的固定大小。编译时大小未知或大小可能发生变化的数据必须存储在堆上。

堆的组织性较差：当您将数据放在堆上时，您需要一定数量的空间。内存分配器在堆中找到一个足够大的空点，将其标记为正在使用，并返回一个指针，即该位置的地址。这个过程称为在堆上分配，有时缩写为just allocating（将值推入堆栈不被视为分配）。因为指向堆的指针是已知的、固定大小的，所以可以将指针存储在堆栈中，但是当您想要实际数据时，必须遵循指针。想想坐在餐厅里。当您进入时，您说明小组中的人数，工作人员会找到一张适合所有人的空桌子并带您到那里。如果您的团队中有人迟到，他们可以询问您的座位以找到您。

推送到堆栈比在堆上分配更快，因为分配器永远不必搜索存储新数据的位置；该位置始终位于堆栈的顶部。相比之下，在堆上分配空间需要更多的工作，因为分配器必须首先找到足够大的空间来保存数据，然后进行记账以准备下一次分配。

访问堆中的数据比访问堆栈中的数据要慢，因为您必须遵循指针才能到达那里。如果现代处理器在内存中跳跃更少，它们会更快。继续进行类比，考虑餐厅的服务器从许多桌子上接受订单。在转移到下一张桌子之前，在一张桌子上获得所有订单是最有效的。从 A 表订购，然后从 B 表订购，然后再从 A 订购，然后再从 B 订购，这将是一个慢得多的过程。出于同样的原因，如果处理器处理靠近其他数据（因为它在堆栈上）而不是更远（因为它可以在堆上）的数据，它可以更好地完成它的工作。在堆上分配大量空间也需要时间。

当您的代码调用函数时，传递给函数的值（可能包括指向堆上数据的指针）和函数的局部变量被推入堆栈。当函数结束时，这些值会从堆栈中弹出。

跟踪代码的哪些部分正在使用堆上的哪些数据，最大限度地减少堆上的重复数据量，以及清理堆上未使用的数据以免空间不足，这些都是所有权解决的问题。一旦了解了所有权，您就不需要经常考虑堆栈和堆，但是知道所有权的主要目的是管理堆数据可以帮助解释为什么它会以这种方式工作。

#### 2. 所有权规则
首先，让我们看一下所有权规则。在我们处理说明它们的示例时，请牢记这些规则：

- Rust 中的每个值都有一个名为owner的变量。
- 一次只能有一个所有者。
- 当所有者超出范围时，该值将被删除。

#### 3. 变量范围

现在我们已经了解了基本的 Rust 语法，我们不会fn main() { 在示例中包含所有代码，因此如果您继续学习，请确保main手动将以下示例放入函数中。因此，我们的示例将更加简洁，让我们专注于实际细节而不是样板代码。

作为所有权的第一个示例，我们将查看一些变量的范围。范围是项目在程序中有效的范围。取以下变量：

```
let s = "hello";
```

该变量s指的是字符串文字，其中字符串的值被硬编码到我们程序的文本中。该变量从声明它的那一刻起一直有效，直到当前作用域结束。清单 4-1 显示了一个带有注释的程序，其中注释了变量的s有效位置。

```
{                      // s is not valid here, it’s not yet declared
	let s = "hello";   // s is valid from this point forward

	// do stuff with s
}                      // this scope is now over, and s is no longer valid
```

##### 3.1. 一个变量及其有效范围

换句话说，这里有两个重要的时间点：

- 当s进入范围时，它是有效的。
- 它在超出范围之前一直有效。

此时，作用域和变量何时有效之间的关系与其他编程语言中的关系类似。String现在我们将通过引入类型来建立在这种理解之上。
